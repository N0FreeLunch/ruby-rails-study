## 해시(hash)
- 키-벨류 쌍을 여러 개 나열한 자료형에 해당한다.
- 가장 간단한 설명은 자바스크립트의 리터럴 오브젝트와 비슷한 역할을 한다.
```rb
{키1: 벨류1, 키2: 벨류2, 키3: 벨류3}
```
- 루비에서 해시는 위와 같은 방식으로 표기한다.
- 루비에서 키로 올 수 있는 값의 타입은 문자열 또는 심볼에 해당한다.
```rb
{'문자열_키' => '값1', :심볼_키 => '값2'}
```

### JSON-style 표기 방식
- JSON-style은 자바스크립트의 리터럴 오브젝트와 비슷한 표기 방식이다.
- 해시를 사용할 때 키와 값의 구분을 위해서 `=>`를 사용하였다.
- 심볼키를 사용하게 되면 심볼에서 사용한 `:`과 키와 값을 구분하기 위해 `:`를 사용하는 것에 혼동을 주기 때문에 루비에서는 심볼을 사용한 키를 사용한 해시의 경우 키와 값을 구분할 때 `:`를 사용하지 못 한다.
- 해시 표기를 할 때 키-벨류의 구분을 `=>`가 아닌 `:`으로 할 때는 모든 키는 심볼이 된다. 키에 문자열 표기 `'` `"`를 사용하든 사용하지 않든 모두 심볼 값으로 키가 세팅이 된다.

#### 가능한 표기
```rb
{ string_key1: "값1", 'string_key2': "값2" }
```

#### 불가능한 표기
```rb
{ string_key1: "값1", 'string_key2' : "값2" }
```
- `키 : ` 키 다음에 콜론(`:`)표기를 띄어쓰기 하면 에러가 발생한다.
- `키: ` 키 다음에 콜론(`:`)은 반드시 붙여 써야 한다.
- `:값`의 경우에는 띄어 써도 되고 붙여 써 줘도 된다. `{ string_key1: "값1", 'string_key2':"값2" }`은 가능하다.

```rb
{ :string_key1: "값1", 'string_key2': "값2" }
```
- `:`으로 키와 벨류를 구분하는 경우에는 키 앞에 `:`을 붙여 심볼으로 표기할 수 없다.
- 하지만 `:`를 붙이지 않더라도 JSON-style의 표기 방식에서 키는 심볼로 세팅된다.

#### 키가 심볼인지 확인 해 보기
```rb
obj = { string_key1: "값1", 'string_key2': "값2" }
obj['string_key1']
obj[:string_key1]
obj[:string_key2]
```
- `obj['string_key1']`의 경우 `nil` 값이 반환된다. 지정한 문자열 `'string_key1'`에 해당하는 키 값이 없기 때문에 에러가 발생한 것이다. 
- `obj[:string_key1]`의 경우 `"값1"`으로 문자열의 값이 선택되어 반환되는 것을 알 수 있다.
- `obj[:string_key2]`의 경우 해시에서 `'string_key2': "값2" `으로 키를 문자열로 입력을 했음에도 불구하고 심볼 타입의 값(`:string_key2`)을 넣었을 때 심볼 값에 해당하는 키가 선택이 되었다. `obj['string_key2']`로 키로 문자열을 넣으면 매칭되는 키가 선택이 되지 않는다. JSON-style의 표기 방식의 경우 해시의 키는 심볼로 설정이 된다는 것을 확인할 수 있다.

---

## 자바스크립트의 리터럴 오브젝트
```js
{키1: 벨류1, 키2: 벨류2, 키3: 벨류3}
```
- 기본적으로 자바스크립트와 똑같은 표기 방식을 가졌다.
```js
var literalObj = {문자열: '문자열', 숫자: 9, 배열: [1,2,3]}
literalObj.숫자
```
- 자바스크립트의 리터럴 오브젝트로의 키로는 심볼, 문자열이 위치할 수 있다.
- 만약 수를 키로 세팅하면, 수는 문자열로 자동으로 변환된다.

### 리터럴 오브젝트의 접근 법
- `오브젝트명.찾을_키_값` 또는 `오브젝트명[찾을_키_값]`의 방식으로 찾을 키 값과 정확히 일치하는 대상을 오브젝트의 키 중에서 선택한다.

---

## 루비의 해시와 자바스크립트 리터럴 오브젝트의 차이
### 키의 문자열 표기 생략
- 리터럴 오브젝트의 경우 키에 문자열을 표기하는 기호 `'` `"` ``` ` ```를 생략할 수 있지만, 루비의 해시는 문자열 키를 생략할 수 없다. 루비의 해시가 JSON-style의 표기인 경우 키에 문자열 기호를 생략할 수 있지만, 자바스크립트의 키에 문자열 기호를 생략하면 문자열로 키가 세팅이 되는 반면, 루비 해시의 JSON-style의 표기의 경우 문자열 기호를 쓰든 쓰지 않든 키는 심볼 타입이 된다.
- 예를 들어 자바스크립트에서는 `{문자열: '문자열'}` 표기가 가능하지만, 루비에서는 `{'문자열': '문자열'}`과 같은 방식으로 `''`를 생략할 수 없다.

### 접근 방식이 제한적
- 루비의 해시를 접근하는 방법은 `해시를_저장한_변수[찾을_키_값]` 방식으로 사용된다.
- 이와 달리 자바스크립트는 `리터럴_오브젝트를_저장한_변수[찾을_키_값]` 또는 `리터럴_오브젝트를_저장한_변수.찾을_키_값`의 방식을 사용할 수 있다.
- 이는 자바스크립트의 리터럴 오브젝트는 키가 객체의 멤버가 되어 객체의 맴버로 접근하는 표기 `.`을 사용할 수 있는 반면, 해시의 경우에는 키가 객체의 맴버가 되지 않기 때문이다. 루비의 해시값은 물론 객체이지만 키가 맴버로 들어 있지 않고 루비의 해시를 다루기 위한 관련 기능들이 들어 있다. 예를 들어 루비의 해시에서 `해시를_저장한_변수.delete(지울_키_값)`을 사용하면 해시에서 지정한 키를 삭제할 수 있다.

---

## Reference
- https://docs.ruby-lang.org/en/3.2/Hash.html