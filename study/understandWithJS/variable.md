## 변수

### 변수명

#### 루비

- 루비의 변수명으로 사용할 수 있는 이름의 규칙은 영문 대소문자, 숫자, \_(언더스코어)를 사용한다.
- 변수명의 첫 글자는 숫자로 시작할 수 없는데 수의 경우 0x로 시작하는 경우 16진수, 0으로 시작하는 경우 8진수, 0b로 시작하는 경우 2진수가 되는 등 숫자로 시작하면 수와 연관된 방식으로 해석을 하기 때문에 변수와 수의 영역을 확실히 구분하기 위해서 변수명은 숫자로 시작하지 않는다. 이것은 대부분의 다른 언어에서도 마찬가지이다.

#### 자바스크립트

- 자바스크립트의 변수명은 다양한 알파벳 문자(영문 대소문자뿐만 아니라 다양한 언어의 문자들로 한글, 한자, 히라가나, 카타카나 등등), 숫자, \_(언더스코어), $(달러) 표기를 변수에 사용할 수 있다.
- 루비와의 차이점은 루비가 변수명으로 영문 대소문자만을 쓸 수 있는 것에 반해, 자바스크립트는 다양한 언어의 알파벳을 사용할 수 있다는 점이다. 물론 자바스크립트에서 다양한 문자를 사용할 수 있지만 일반적으로 영대소자를 변수명에 사용한다.

### 변수 선언의 종류

- 자바스크립트에서는 var, const, let 등의 변수를 선언하는 키워드가 있고 이를 통해서 변수의 특성을 설정할 수 있다. `var`는 function 함수를 지역변수 범위로 하는 재할당 가능한 변수이고, let은 중괄호 {}를 지역변수 범위로 하는 재할당 가능한 변수이고, const는 중괄호 {}를 지역변수 범위로 하는 재할당 불가능한 변수이다.
- 자바스크립트에서 변수를 선언할 수 있는 것과 달리 루비 언어의 변수는 선언하는 키워드가 없다. 하지만 변수를 표기하는 방식에 따라서 변수의 특징이 달라지는데 그냥 '변수명'인 경우에는 지역변수, '$변수명'은 전역변수로 사용하는 방법이 있다. 또한 루비에서는 자바스크립트와 같이 상수를 선언하는 키워드는 없지만 변수명의 첫 문자가 대문자로 시작하면 재할당이 불가능한 상수가 된다.
- 자바스크립트에서 지역변수의 범위를 결정하는 것은 중괄호이다. (var의 경우는 function 키워드 함수의 중괄호이다.) 루비에서 지역변수의 범위는 범위를 여는 키워드 def, do으로 시작해서 end로 끝나는 영역까지가 지역변수의 범위이다.

### 변수의 재할당

```js
var a = 1;
a = 2;
console.log(a);
let b = 3;
b = 4;
console.log(b);
```

- 자바스크립트에서 `var` 또는 `let` 으로 선언한 변수는 재할당 가능하다. 따라서 선언될 때 할당된 값이 아닌 재할당된 값이 `console.log`에 출력된다.

```rb
a = 1
a = 2
puts a
b = 3
b = 4
puts b
```

- 루비의 변수도 마찬가지로 재할당이 가능하다. 따라서 처음 변수를 생성할 때 할당된 값이 아닌 재할당된 값이 `puts`에 출력된다.

### 상수

```js
const immutable = 1;
immutable = 2;
```

-　위의 자바스크립트 코드는 상수로 선언된 변수 `immutable`에 재할당을 하려고 시도했기 때문에 에러가 발생하는 코드이다. 상수로 선언된 변수는 재할당을 할 수 없다.

```rb
Immutable = 1
Immutable = 2
```

- 위의 루비 코드는 변수의 첫 문자가 대문자이므로 상수이다. 따라서 재할당이 불가능하다. 하지만 다음과 같이 첫 문자를 대문자로 쓰지 않는다면 상수가 되지 않으므로 재할당을 할 수 있다.

```rb
immutable = 1
immutable = 2
puts immutable
```

### 지역변수

- 프로그래밍 언어에서 생성된 변수가 살아 있는 영역을 스코프라고 부른다.

```js
function foo() {
  var a = 1;
  console.log(`inner a = ${a}`);
}

foo();
console.log(`outer a = ${a}`);
```

- 위 코드에서 a는 foo라는 함수가 실행되는 동안만 살아있는 변수이다. `foo()`라는 함수 실행 코드에 의해서 함수가 실행되면, 함수의 중괄호가 시작하는 부분 `{`부터의 코드를 실행하여 `}`로 함수가 끝나는 부분까지는 함수 내부의 코드가 실행된다.
- 함수가 실행되고 끝나기 전까지의 코드에서 선언된 변수는 함수가 끝날 때까지 함수 내에서 사용할 수 있으며, 함수가 끝나면 함수 내에서 생성된 변수를 더 이상 사용할 수 없다.
- 위의 코드에서 `var a = 1`으로 함수가 실행되고 종료되기 전 사이에 변수가 생성되었다. 이 변수는 함수가 끝나기 전의 코드의 실행에서는 살아있기 때문에 `` console.log(`inner a = ${a}`) ``코드에서 변수 `a`의 값인 1이 표시된다.
- 스코프 내에서 생성된 변수는 스코프 밖에서는 수명이 종료된다. `foo()`라는 코드는 함수를 실행한다는 의미도 있지만, 함수 내부의 코드들을 실행하고 함수를 종료한다는 의미도 갖고 있다. 함수 내에서 생성된 변수는 함수가 종료된 이후에는 사라지므로 함수 밖의 `` console.log(`outer a = ${a}`) `` 코드에서는 변수 `a`가 사라져서 실행할 수 없다. 존재하지 않는 변수의 값을 접근하려고 시도했기 때문에 `Uncaught ReferenceError: a is not defined`라는 에러가 발생한다.

```rb
def foo
  a = 1
  puts "inner a = #{a}"
end

foo

puts "outer a = #{a}"
```

- 앞선 자바스크립트 코드를 루비로 만든 것이다. `foo`를 통해서 함수가 실행이 되었고, `def foo`로 함수 내부의 코드가 실행이 되고, `end`으로 함수가 종료된다. 함수 내부의 코드가 실행이 될 때 `a = 1`로 변수가 생성된다. 이 변수는 함수가 종료될 때까지 살아있으므로 `puts "inner a = #{a}"`의 코드의 `#{a}` 부분이 1로 바뀐 결과를 갖는다. 하지만 함수가 종료된 이후 실행되는 `puts "outer a = #{a}"`에서는 더 이상 변수 `a`가 존재하지 않기 때문에 존재하지 않는 a값을 사용하려고 하기 때문에 에러가 발생한다. 존재하지 않는 변수에 접근하려고 시도했기 때문에 `undefined local variable or method `a'`라는 에러 메시지가 나온다.
