## 마이그레이션
### 테이블
| id | 걸그룹 | 멤버 이름 | 소속사 |
|----|------|---------|------|
| 1 | 트와이스 | 사나 | JYP |
| 2 | 트와이스 | 나연 | JYP |
| 3 | 블랙핑크 | 지수 | YG |
| 4 | 러블리즈 | 케이 | woollim |
| 5 | 소녀시대 | 윤아 | SM |

- 테이블은 `표`와 같은 방식으로 데이터를 저장하기 위한 데이터베이스의 기능이다.

### 데이터베이스
- 데이터베이스는 데이터를 저장히기 위한 테이블을 만들 수 있는 곳으로 데이터를 저장하고 조회하기 위한 다양한 기능들을 제공한다. 데이터베이스를 다루기 위해서는 '쿼리'라는 명령을 사용한다.
- 일반적으로 데이터베이스를 다루기 위한 쿼리 명령은 데이터베이스 프로그램을 통해서 사용할 수 있다.
- 프로그래밍 언어에서 데이터베이스를 다루기 위해서는 프로그래밍 언어로 데이터베이스 프로그램을 컨트롤하여 원하는 쿼리를 데이터베이스 프로그램이 실행할 수 있도록 하는 방식으로 사용된다.
- 따라서 프로그래밍 언어에서 데이터베이스를 사용하기 위해서는 프로그래밍 언어와 데이터베이스 프로그램을 연결하는 기능이 필요하며 데이터베이스 프로그램에 프로그래밍 언어가 명령을 전달하여 쿼리를 실행하도록 할 필요가 있다.

## 엑티브레코드
- 데이터베이스를 사용하기 위해서는 쿼리라는 데이터베이스를 다룰 때 사용하는 명령어를 알아야 한다.
- 많은 웹 프레임워크와 라이브러리는 프로그래밍 언어를 사용해서 쿼리를 정의하는 방법을 제공한다. 데이터베이스를 조작하기 위해서는 쿼리라는 것을 알아야 하는데, 쿼리를 몰라도 라이브러리나 프레임워크가 제공하는 명령을 사용하면 된다.
- 루비온 레일즈에서 쿼리를 몰라도 데이터베이스를 다룰 수 있도록 도와주는 도구 중 하나가 엑티브레코드이다.

## 흐름
1. 엑티브 레코드가 제공하는 기능과 루비 언어를 사용해서 데이터베이스를 다루는 명령을 정의한다.
2. 엑티브 레코드가 프로그래밍 언어를 쿼리로 변환하여 데이터베이스로 쿼리를 전달한다.
3. 데이터베이스 프로그램은 전달 받은 쿼리를 실행한다.
4. 쿼리에 따라 데이터베이스에 저장된 데이터의 변경 또는 저장 방식의 변경 또는 저장된 데이터의 조회 명령을 수행한다.
5. 명령을 수행한 결과 값을 데이터베이스가 엑티브레코드에 전달한다.
6. 엑티브레코드가 프로그래밍 언어의 값으로 데이터 변환하여 루비 언어를 통해 데이터를 다룰 수 있게 된다.

## 마이그레이션이란?
- 마이그레이션이란 데이터베이스를 구성하는데 필요한 쿼리를 실행하기 위한 명령을 데이터베이스에 전달하는 과정을 의미한다.
- 마이그레이션을 하는 대표적인 작업은 데이터를 저장히기 위한 테이블을 만드는 작업이다.

## 모델
- 모델은 데이터베이스의 테이블을 레일즈에서 엑티브레코드로 다룰 수 있도록 하기 위한 기능이다.
- 모델은 테이블에 들어 있는 데이터를 적절히 가공하는 역할을 한다.

## 모델과 마이그레이션 만들어 보기
```sh
rails g model Photo path:string caption:text
```
- 레일즈에서는 `rails g model 모델명 컬럼1:타입 컬럼2:타입 컬럼3:타입 ...`과 같은 방식으로 모델과 마이그레이션 파일을 만들 수 있다.
- 마이그레이션 파일을 만들지 않고 모델 파일만 만드는 경우에는 레일즈에서는 `rails g model 모델명`만 터미널에 입력한다.
- 마이그레이션 파일을 만들나서 이 마이그레이션 파일을 `rake db:migrate`라는 명령으로 터미널에서 실행하면 마이그레이션 파일을 통해서 데이터 베이스의 구조를 바꿀 수 있다.
- 생성된 마이그레이션 파일은 `path:string caption:text`와 같은 데이블을 만드는데 이 파일은 다음과 같이 표 형식으로 데이터를 저장할 수 있는 테이블을 데이터베이스에 생성한다.

| id | path | caption |
|----|------|---------|
| 1 | 사진첩/초코 케이크.png | 생일날 먹은 케익 |
| 2 | 사진첩/남방 돌고래.jpg | 제주도 놀러 갔을 때 남방 돌고래 찍은 사진 |

### 실행 결과
- `rails g model Photo path:string caption:text` 명령을 실행한 결과이다.
```
      invoke  active_record
      create    db/migrate/20230518155320_create_photos.rb
      create    app/models/photo.rb
      invoke    test_unit
      create      test/models/photo_test.rb
      create      test/fixtures/photos.yml
```
- `db/migrate/20230518155320_create_photos.rb`라는 마이그레이션 파일이 생성된다. 이 파일로 데이터베이스에 테이블을 형성할 수 있다.
- `app/models/photo.rb`라는 모델 파일이 생성된다. 이 파일로 루비의 엑티브레코드로 데이터베이스에 생성된 테이블에 데이터를 저장하거나, 데이터를 변경하거나, 데이터를 삭제할 수 있다.
- 나머지 파일은 유닛 태스트용의 파일인데 지금 단계에서는 무시해도 좋다.

## 마이그레이션 파일 이해하기
- 마이그레이션 파일은 데이터베이스의 구조를 변경하기 위한 코드가 포함되어 있는 파일이다.
- `db/migrate/20230518155320_create_photos.rb` 경로의 파일을 열어 보자.
```rb
class CreatePhotos < ActiveRecord::Migration[7.0]
  def change
    create_table :photos do |t|
      t.string :path
      t.text :caption

      t.timestamps
    end
  end
end
```
- `CreatePhotos` 클래스는 마이그레이션 파일에 데이터베이스의 구조를 변경하기 위한 명령을 정의하는 부분이다.
- `ActiveRecord::Migration`에서 `ActiveRecord`는 데이터베이스의 구조를 다루기 위한 기능들이 포함되어 있는 곳이다. 많은 기능들 중에서 `ActiveRecord`클래스에 포함되어 있는 `Migration` 클래스를 `CreatePhotos` 클래스에 상속하겠다는 의미이다. 따라서 `CreatePhotos` 클래스는 `ActiveRecord::Migration` 클래스가 갖고 있는 기능들을 사용할 수 있는 클래스가 된다.
- 클래스 내부에 `def change ... end`의 형태로 함수를 적어 주었다. `change` 함수는 테이블에 관련한 코드를 지정할 수 있다. `change` 함수 안을 보면 테이블을 생성하는 명령 `create_table`이 사용되었다는 것을 알 수 있다.
- 테이블을 생성할 때는 컬럼(=세로 줄인 열)을 지정해 주어야 한다. 컬럼은 데이터를 저장할 공간에 어떤 데이터를 저장할 것인지를 결정한다. 예를 들어 `string` 타입의 컬럼인 `path`와 `text` 타입의 컬럼인 `caption`을 지정하면 데이터를 저장할 때 `path`와 `caption`에 해당하는 데이터 세트가 저장이 된다. 컬럼에 무엇을 어떻게 얼마나 정의하냐에 따라 저장되는 데이터 세트의 구성이 달라진다.
- `create_table`는 `ActiveRecord::Migration`에서 상속을 받은 기능으로 테이블에 관련된 조작을 할 수 있는 메소드로 마이그레이션 명령으로 실행이 될 때, 데이터베이스의 테이블을 생성하는데 필요한 코드 블록을 사용할 수 있게 해 준다.
- `create_table` 함수는 첫 번째 인자로 `:photos`라는 심볼 타입의 값을 받는다. 심볼은 루비 언어에서 주로 어떤 정해진 옵션이나 값으로 사용되며, 다양한 곳에서 반복적으로 사용되는 문자열은 심볼로 선언하여 컴퓨팅 리소스를 아낄 수 있으므로 테이블명이나, 컬럼명을 심볼로 만드는 방식을 사용한다.
- `do ... end` 구문은 블록이라는 개념이다. 블록이란 개념은 루비에만 있는 특이한 개념으로 코드 덩어리를 주입한다는 의미를 가지고 있다. `create_table` 함수는 첫 번째 인자로 테이블명에 해당하는 심볼을 받고, 함수의 인자와는 별개로 블록이란 코드 덩어리를 받을 수 있다. 이 코드 덩어리는 데이터베이스의 테이블 구조를 변경할 수 있는 특수한 방식으로 사용되는 코드 덩어리이다.
- `create_table`의 블록 안에 입력할 수 있는 코드 구문은 컬럼 타입을 정의할 수 있는 객체 `t`를 블록 파라메터 |t|로 받아서 `t`의 메소드(= 객체가 가지고 있는 함수)인 `t.string`란 메소드는 인자로 `:path`라는 심볼을 받고, `t.text`라는 메소드는 인자로 `:caption`라는 심볼을 받는다.
- `t.timestamps`는 심볼을 인자로 받지 않고 자동으로 `id` 컬럼, `created_at` 컬럼 `updated_at` 컬럼을 만드는 기능을 갖고 있다.

## 생성된 테이블
| id | path | caption | created_at | updated_at |
|----|------|---------| ---------- | ---------- |
| 1 | 사진첩/초코 케이크.png | 생일날 먹은 케익 | 2023-05-01 | 2023-05-01 |
| 2 | 사진첩/남방 돌고래.jpg | 제주도 놀러 갔을 때 남방 돌고래 찍은 사진 | 2023-05-15 | 2023-05-15 |

## 루비 언어 이해하기
### 심볼
- 심볼 타입은 `:심볼_이름`과 같은 방법으로 사용하고 문자열과 달리 변경을 할 수 없는 값이다. 예를 들어 `'문자열'`이란 값은 `'문자'`라는 값, `'문열자'` 등등 동일한 값을 계속 변경할 수 있는 반면, 심볼 값은 이런 변경이 불가능하다.
- 또한 심볼은 서로 떨어진 코드에서 실행된 심볼이 서로 같은 동일한 값으로 서로 같은 주소의 값인 것에 반해 문자열은 서로 다른 부분에서 만들어진 문자열은 동일한 문자열이 나열되어 있다고 해도 서로 다른 값이다. 물론 `==`와 같은 비교 표현식에서는 동일하다고 하지만 각각은 컴퓨터의 프로그래밍 언어가 다루는 메모리 공간에서 서로 다른 주소에 저장된 값이다.
- 심볼을 사용하면 여러 곳에서 사용한 동일한 이름의 심볼이 동일한 값이기 때문에 메모리를 적게 차지하여 리소스 관리 차원에서 문자열에 비해 효율적이다.

### 블록
- 루비 언어의 함수는 함수의 파라메터로 인자를 받는 것 대신에 블록이란 것을 받을 수도 있다.
- 블록이란 문법은 다른 프로그래밍 언어에서는 찾아 보기 힘든 루비만의 독특한 문법이다. 다른 프로그래밍 언어에서는 값으로 쓰일 수 있는 대상을 전달하고 전달받는 방식이지만, 한나의 값이 아닌 코드 덩어리를 전달하고 전달 받을 수 있는 특이한 구문이 블록이다.
- 루비에서 `do ... end` 형태로 쓰이면 블록에 해당하는 부분으로 보면 된다.
- `do` 앞에 나온 대상에 따라 블록 내에 쓰일 수 있는 코드 정의 방식이 달라진다.
- 또한 `do` 뒤에는 `|block_param1, block_param2, block_param3|`와 같은 방식으로 블록 파라메터를 정할 수 있다. 또는 `|(block_param1, block_param2, block_param3)|`와 같이 괄호를 붙여 줄 수도 있다.
- 블록 파라메터는 해당 블록을 사용하는 대상으로 부터 파라메터로 받아서 블록 내의 코드를 실행하도록 되어 있다.

## 마이그레이션 하기
```rb
rake db:migrate
```
- 위 명령어를 터미널에 입력하면
```
== 20230518155320 CreatePhotos: migrating =====================================
-- create_table(:photos)
   -> 0.0007s
== 20230518155320 CreatePhotos: migrated (0.0007s) ============================
```
- 위와 같은 메시지가 뜨면서 마이그레이션이 수행되었다는 것을 확인할 수 있다.
- 이제 데이터베이스 안에는 `photos`라는 이름의 테이블이 만들어지고, 이 테이블 안에는 `id`, `path`, `caption`, `created_at`, `updated_at`이라는 컬럼이 정의되었다.

## 자바스크립트 문법으로 이해하기
```js
class CreatePhotos extends ActiveRecord.Migration {
  change () {
    this.create_table(symbol.for('photos'), (t) => {
      t.string(symbol.for('path'));
      t.text(symbol.for('caption'));
      t.timestamps();
    });
  }
}
```
- 위의 코드는 직접 실행되지는 않는 코드이다. 왜냐하면 ` ActiveRecord.Migration`가 정의되지 않았기 때문이다. 하지만 자바스크립트로 나타내면 위와 비슷한 방식으로 표현될 수 있다는 것을 이해한다면 레일즈에 등장한 문법을 좀 더 이해하기 쉬울 것이다.
- `do ... end`에 해당하는 블록은 자바스크립트에서는 없는 문법이다. 따라서 함수의 인자를 하나 더 받아서 파라메터를 사용할 수 있는 함수 표현으로 바꾸는 방식으로 코드를 표현하였다.
- 자바스크립트에서 루비 언어의 심볼 타입과 비슷한 심볼을 사용하기 위해서는 `symbol.for('심볼_이름')` 방식의 표현을 사용해야 한다. 자바스크립트 심볼에 대한 자세한 정보는 다음을 참고하자 => [루비와 자바스크립트의 심볼](../understandWithJS/symbol.md)

---
---
## 깃허브에 올리기
```sh
git status
```
- 위 명령어로 바로 이전 커밋에서 기록을 남긴 파일들과 비교했을 때 변경된 파일들을 확인할 수 있다.
```
추적하지 않는 파일:
  (커밋할 사항에 포함하려면 "git add <파일>..."을 사용하십시오)
        app/models/photo.rb
        db/migrate/
        db/schema.rb
        test/fixtures/photos.yml
        test/models/photo_test.rb
```
- 빨간색 글씨로 위의 파일 리스트가 뜬다. 직전 커밋 기록에서 변경사항이 있는 파일이거나 새로운 파일이라면 위와 같이 파일 리스트가 뜬다.
- `rails g model Photo path:string caption:text`이란 명령을 사용하면서 만들어진 파일들이다.
- `추적하지 않는 파일:`이라고 메시지가 나와 있는데 새로 만든 파일은 기존에 기록으로 남기지 않은 파일이라는 의미를 가지고 있다. 즉 한 번도 커밋이 이뤄지지 않은 파일이라는 것이다.

```sh
git add *
```
- 위 명령어를 사용하면 리스트에 있는 모든 파일이 선택된다.
```sh
git status
```
- 위의 명령어를 치면 위의 빨간색의 파일 경로들이 초록색으로 바뀐 것을 확인할 수 있다.
```
커밋할 변경 사항:
  (use "git restore --staged <file>..." to unstage)
        새 파일:       app/models/photo.rb
        새 파일:       db/migrate/20230518155320_create_photos.rb
        새 파일:       db/schema.rb
        새 파일:       test/fixtures/photos.yml
        새 파일:       test/models/photo_test.rb
```
- 동일한 폴더 경로가 `추적하지 않는 파일` 부분에 있었는데 `git add`로 추가하고 나서는 `커밋할 변경 사항` 쪽에 위치하게 된다.
- 깃에서 커밋으로 기록을 남길 때에는 빨간색의 파일 경로는 기록으로 남기지 않고 초록색 파일 경로만 기록으로 남긴다.
```sh
git reset 경로명
```
- `git add *` 명령어를 쳐서 초록색으로 변한 파일 중에 커밋 대상에서 배제하고 싶은 파일이 있다면 위의 명령어를 통해서 초록색으로 변한 파일 경로를 빨간색으로 변경 시킬 수 있다. 그럼 커밋으로 기록을 남길 때 제외될 수 있다.
```sh
git reset app/models/photo.rb
git reset test/fixtures/photos.yml
git reset test/models/photo_test.rb
```
- 우선 마이그레이션 파일만 따로 커밋을 해 보자 그러기 위해서는 마이그레이션 파일 이외의 파일을 빨간색으로 만들어야 한다.
```sh
git status
```
- 위 명령어를 입력하면
```
커밋할 변경 사항:
  (use "git restore --staged <file>..." to unstage)
        새 파일:       db/migrate/20230518155320_create_photos.rb
        새 파일:       db/schema.rb

추적하지 않는 파일:
  (커밋할 사항에 포함하려면 "git add <파일>..."을 사용하십시오)
        app/models/photo.rb
        test/fixtures/photos.yml
        test/models/photo_test.rb
```
- 커밋할 대상과 커밋하지 않은 대상이 분리되는 것을 확인할 수 있다.
```
git commit -m "마이그레이션 파일 등록"
```
- 위 명령어를 입력하면 `db/migrate/20230518155320_create_photos.rb` 파일과 `db/schema.rb` 파일이 커밋되어 깃의 기록으로 남는다.
```
 2 files changed, 31 insertions(+)
 create mode 100644 db/migrate/20230518155320_create_photos.rb
 create mode 100644 db/schema.rb
```
- 커밋이 이뤄지면 위와 같은 메시지가 나온다. 2개의 파일이 변경되었고, 31개의 코드라인이 추가 되었다는 의미이다.
```sh
git status
```
```
추적하지 않는 파일:
  (커밋할 사항에 포함하려면 "git add <파일>..."을 사용하십시오)
        app/models/photo.rb
        test/fixtures/photos.yml
        test/models/photo_test.rb
```
- 이제 남은 파일들을 따로 명칭을 붙여서 커밋을 해 보자.
```sh
git add *
```
- 참고로 `git add *` 뿐만 아니라 `git add .`이란 명령어도 있다. `git add .`은 파일명의 첫 글자가 `.`으로 시작되는 대상도 포함한 모든 파일을 커밋 대상으로 등록한다는 의미이고, `git add *`는 첫 글자가 `.`으로 시작되는 대상을 배제한 모든 파일을 커밋 대상으로 등록한다는 의미를 가지고 있다.
```sh
git status
```
```
커밋할 변경 사항:
  (use "git restore --staged <file>..." to unstage)
        새 파일:       app/models/photo.rb
        새 파일:       test/fixtures/photos.yml
        새 파일:       test/models/photo_test.rb
```
- 위의 리스트들이 초록색으로 변했다.
```sh
git commit -m "photo 테이블을 다룰 수 있는 photo 모델 파일 생성"
```

### 깃 허브에 들록하기
- 깃 허브에 등록되는 코드는 커밋이 이뤄진 코드가 등록이 된다.
```sh
git push origin main
```
- git : git 명령어로
- push : 리포트 저장소에 커밋 기록을 등록할 건데
- origin : origin 이라고 이름 붙여둔 경로로 커밋 기록을 보낼 거야
- main : main 브렌치에 파일을 보낼 거야 (브렌치에 대한 설명은 나중에 하도록 하자.)
라는 의미를 가지고 있다.

### origin
```sh
git remote -v
```
- 위의 명령어를 입력 해 보자.
```
origin  https://github.com/깃허브_유저명/리포지토리명.git (fetch)
origin  https://github.com/깃허브_유저명/리포지토리명.git (push)
```
- `origin` 이라는 이름은 오른쪽의 경로로 지정이 되어 있다는 의미이다.
- `origin`이 아닌 다른 이름으로 커밋 기록을 전송할 주소를 정할 수 있다.
- 예를 들어 경로의 별칭을 `moon`이라고 바꾸면 (실제 깃을 사용할 때 origin 명칭을 거의 바꾸지 않는다. 따라서 바꿀 수 있다는 것 정도만 알아 두자.)
```
moon  https://github.com/깃허브_유저명/리포지토리명.git (fetch)
moon  https://github.com/깃허브_유저명/리포지토리명.git (push)
```
- 위와 같이 바꾼다면 깃허브에 코드를 등록할 때 `git push moon main` 이라는 명령으로 깃허브에 커밋 기록을 전송할 수 있다. 물론 url 주소에 따라 `github`가 아닌 다른 곳에 보낼 수도 있다. `github`와 비슷한 서비스를 하는 서비스로는 `bitbucket`, `gitlab` 등 다양한 서비스가 있다. 이들마다 기본적으로 지정되는 origin의 경로의 도메인(`github.com` 부분)은 달라진다.